#N canvas 190 75 1090 589 12;
#X obj 31 350 loadbang;
#X obj 31 398 s bela_setSerial;
#X obj 29 462 route myserial;
#X msg 31 374 new myserial /dev/ttyS4 9600 none bytes;
#X obj 355 486 s bela_serialOut;
#X obj 355 385 metro 1000;
#X obj 355 361 loadbang;
#X obj 403 413 + 1;
#X obj 355 412 f;
#X msg 355 455 myserial \$1 2 3 4 5 6;
#X obj 29 438 r bela_serialIn;
#X obj 29 486 print serialIn;
#X text 73 20 Send a `new` message to bela_setSerial to initialise UART communication. Arguments are:;
#X text 69 50 [new <serialId> <device> <bps> <EOM> <type>;
#X text 72 65 Where:;
#X text 82 78 serialId: symbol to use in future communications pertaining this object;
#X text 85 133 bps: a valid baudrate supported by the device;
#X text 85 111 device: path to the serial device;
#X text 85 154 EOM: End Of Message byte \, used to identify boundaries;
#X text 102 168 in incoming messages. Possible values are:;
#X text 101 183 `none` (no message splitting) \, `newline` \, or a float;
#X text 103 198 representing the character code;
#X text 82 216 type: how the data is output from bela_serialIn. Possible;
#X text 101 231 values are:;
#X text 99 263 symbol: convert incoming message string to a symbol;
#X text 100 246 floats: convert incoming message string to a float;
#X text 99 279 symbols: convert incoming data to a symbol ignoring EOM;
#X text 98 294 bytes: convert each incoming byte to a float \, output them;
#X text 98 307 one byte at a time if EOM is none \, or as one list per message;
#X text 442 413 Output raw bytes (that's the only output mode supported right now);
#X connect 0 0 3 0;
#X connect 2 0 11 0;
#X connect 3 0 1 0;
#X connect 5 0 8 0;
#X connect 6 0 5 0;
#X connect 7 0 8 1;
#X connect 8 0 7 0;
#X connect 8 0 9 0;
#X connect 9 0 4 0;
#X connect 10 0 2 0;
